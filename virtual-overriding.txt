1) 가상 함수(virtual function)란?

 

C++에서 가상 함수(virtual function)는 파생 클래스에서 재정의할 것으로 기대하는 멤버 함수를 의미합니다.

 

이러한 가상 함수는 자신을 호출하는 객체의 동적 타입에 따라 실제 호출할 함수가 결정됩니다.

 

C++에서 가상 함수는 virtual 키워드를 사용하여 선언합니다.

 

virtual 특징

 

1. 클래스의 공개(public) 섹션에 선언합니다.

 

2. 가상 함수는 정적(static)일 수 없으며 다른 클래스의 친구(friend) 함수가 될 수도 없습니다.

 

3. 가상 함수는 실행시간 다형성을 얻기위해 기본 클래스의 포인터 또는 참조를 통해 접근(access)해야 합니다.

 

4. 가상 함수의 프로토타입(반환형과 매개변수)은 기본 클래스와 파생 클래스에서 동일합니다.

 

5. 클래스는 가상 소멸자를 가질 수 있지만 가상 생성자를 가질 수 없습니다.

 

6. 따로 자녀 클래스에서 함수 설정을 하지 않더라도 기능이 작동합니다.

 

 

2) 순수 가상 함수(pure virtual function)란?

 

가상 함수와는 달리 순수 가상 함수(pure virtual function)란 파생 클래스에서 반드시 재정의해야 하는 멤버 함수를 의미합니다.

 

이러한 순수 가상 함수는 일반적으로 함수의 동작을 정의하는 본체를 가지고 있지 않습니다.

 

따라서 파생 클래스에서 재정의하지 않으면 사용할 수 없습니다.

 

 

3) 오버라이딩은 왜 필요할까?

오버라이딩이 일단은 왜 필요할까에 대해서 생각해 봤습니다.

 

일단 사람이란 객체를 예로 들어 설명하겠습니다.

사람은 자신의 아버지로부터 태어났습니다. 그리고 자신의 아버지의 유전정보를 상속받았습니다. 둘다 동일한 기능을 가지고 있습니다. 아버지는 ‘말한다’라는 기능을 물려받았습니다. 하지만 그렇다고 자식이 말하는 것과 아버지가 말하는 것이 완전히 같은 기능을 가지고 있는 것은 아닙니다. 왜냐하면 자식은 자신의 스타일의 말한다는 기능을 재정의 한 것 이기 때문입니다.

간단히 예를 들면 아버지가 안녕? 한다고 자식도 안녕?이라고 말하는 스타일이 같을까요? 아닙니다. 아들은 아들의 스타일대로 안녕?이라고 말할것입니다. 이처럼 상속받은 기능이나 상속받은 객체의 스타일에 맞도록 재정의 하는 것이 오버라이딩이기 때문에 중요합니다.

 

또 하나의 예로 게임을 들자면 100개의 다른 유닛에게 각각 공격명령을 내릴 때 오버라이딩이 존재하지 않는다면 100번을 호출해야하는데 그런 자원낭비는 매우 비효율적입니다. 이를 방지하기 위해 각 유닛의 정보가 들어있는 클래스의 상위 클래스에서 공격명령을 정의한다면 따로 공격명령에 대한 정의를 할 필요가 없어집니다. 이런 단적인 예로 미루어 보아 최적화를 하기위해 오버라이딩이 필요하다고 생각합니다.

 

 

4) C++이란?

C++은 기존의 C언어에 여러 가지 기능을 추가하여 만든 프로그래밍 언어입니다.

C++은 C언어를 기초로 삼아 만든 언어이므로, 기존의 C 표준 라이브러리를 그대로 사용할 수 있습니다.

 

5) C++의 특징

 

1. C++은 절차 지향적이며 구조적 프로그래밍 언어입니다.

 

2. C++은 객체 지향 프로그래밍 언어입니다.

 

3. C++은 일반화 프로그래밍 언어입니다.

